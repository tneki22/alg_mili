## Минимизация автомата Мили

Это небольшое учебное веб‑приложение на Streamlit для пошаговой минимизации конечного автомата Мили по алгоритму из методички.

В репозитории есть три ключевых файла:

- `app.py` – основной Streamlit‑интерфейс и реализация алгоритма минимизации;
- `mili_no_int.py` – консольная версия того же алгоритма на фиксированном примере;
- `context.md` – текстовое теоретическое объяснение алгоритма (эквивалентные состояния, разбиения Σij, минимальный автомат).

---

### 1. Модель автомата и структуры данных

Автомат Мили задаётся четырьмя объектами:

- **входы** `inputs`: список номеров входов  
  Пример: `inputs = [1, 2, 3]` соответствует столбцам `a1, a2, a3`.

- **состояния** `states`: список номеров состояний  
  Пример: `states = [1, 2, ..., 9]`.

- **таблица выходов** `outputs`: словарь словарей  
  `outputs[state][input] = y(t)` – выход автомата в состоянии `state` при входе `input`.  
  Пример:
  ```python
  outputs = {
      1: {1: 0, 2: 1, 3: 1},
      2: {1: 1, 2: 0, 3: 0},
      # ...
  }
  ```

- **таблица переходов** `next_state`: словарь словарей  
  `next_state[state][input] = s(t+1)` – в какое состояние переходит автомат.  
  Пример:
  ```python
  next_state = {
      1: {1: 2, 2: 4, 3: 4},
      2: {1: 1, 2: 1, 3: 5},
      # ...
  }
  ```

Все функции алгоритма работают только с этими структурами данных и не зависят от Streamlit:

- `build_primary_classes(states, inputs, outputs)` – строит первичное разбиение Σ1j;
- `refine_partition(partition, inputs, next_state)` – делает один шаг уточнения Σi → Σ(i+1);
- `run_minimization(inputs, states, outputs, next_state)` – запускает все этапы и возвращает строку‑отчёт.

---

### 2. Алгоритм минимизации (в терминах `context.md`)

Алгоритм реализует классическую схему из `context.md`:

1. **Первичное разбиение Σ1j (`build_primary_classes`)**
   - Для каждого состояния `s` берётся строка выходов \((y(a1), ..., y(am))\).
   - Состояния с одинаковыми строками выходов попадают в один первичный класс Σ1j.

2. **Итерационное уточнение Σ(i+1)j (`refine_partition`)**
   - На каждом шаге есть текущее разбиение `partition = [Σi1, Σi2, ...]`.
   - Внутри каждого класса Σij состояния группируются по «подписи» переходов:
     \[
     signature(s) = ( class(next\_state(s, a1)), ..., class(next\_state(s, am)) )
     \]
   - Если класс не делится – он переносится как есть.
   - Если делится – первый подкласс остаётся на месте, остальные добавляются в конец списка (получают новые номера).
   - Цикл повторяется, пока разбиение не перестаёт меняться (Σ(i+1) == Σi).

3. **Минимальный автомат Ã (`run_minimization`)**
   - Эквивалентное устойчивое разбиение \(P\_{экв} = \{Σ1, Σ2, …, Σm\}\) берётся из последнего шага.
   - Каждому классу Σj ставится в соответствие новое состояние S(j).
   - В качестве **представителя** класса берётся состояние с минимальным номером из Σj.
   - Выходы минимального автомата:
     \[
     f\_y^{min}(j, a) = f\_y(\text{rep}(Σj), a)
     \]
   - Переходы минимального автомата:
     \[
     f\_s^{min}(j, a) = k,\ \text{если } next\_state(\text{rep}(Σj), a) \in Σk
     \]
   - `run_minimization` возвращает текст, в котором:
     - показываются разбиения Σ1j, Σ2j, … до стабилизации;
     - перечисляются эквивалентные классы Pэкв;
     - строится таблица минимального автомата по новым состояниям S(j).

---

### 3. Как устроен интерфейс Streamlit (`app.py`)

Интерфейс использует `st.session_state` для хранения текущих таблиц:

- `st.session_state["outputs"]` – текущая таблица выходов;
- `st.session_state["next_state"]` – текущая таблица переходов.

Основные блоки:

- **Параметры автомата**  
  В левой колонке задаются:
  - количество состояний `num_states`,
  - количество входов `num_inputs`,
  - максимальное значение выходного сигнала (используется только как подсказка).

- **Кнопка «Загрузить дефолтный пример из тетради»**  
  Заполняет `session_state["outputs"]` и `session_state["next_state"]` конкретным примером из конспекта.

- **Редактируемые таблицы (`st.data_editor`)**
  - Таблица выходов `y(t)` формируется из `session_state["outputs"]` и показывается пользователю.
  - После редактирования результат снова превращается в словарь вида `outputs[state][input]`.
  - Аналогично обрабатывается таблица переходов `s(t+1)`.
  - Пустые ячейки (NaN) превращаются:
    - в `0` для выходов;
    - в `1` для переходов (по умолчанию переход в состояние 1).

- **Кнопка «Запустить минимизацию»**
  1. Забирает нормализованные словари `outputs_dict` и `next_state_dict` из `session_state`.
  2. Проверяет корректность: все значения `s(t+1)` должны лежать в диапазоне `[1, num_states]`. Если нет – показывает таблицу с некорректными ячейками и останавливается.
  3. Вызывает:
     ```python
     result = run_minimization(
         inputs=list(range(1, num_inputs + 1)),
         states=list(range(1, num_states + 1)),
         outputs=outputs_dict,
         next_state=next_state_dict
     )
     ```
  4. Показывает текстовый отчёт в `st.text(result)`.

Таким образом, Streamlit‑часть отвечает только за ввод/вывод и подготовку словарей, а математический алгоритм полностью инкапсулирован в чистых функциях в начале `app.py`.

---

### 4. Как запустить

1. Установите зависимости (Streamlit и Pandas), например:
   ```bash
   pip install streamlit pandas
   ```

2. Запустите приложение:
   ```bash
   streamlit run app.py
   ```

3. В браузере:
   - задайте количество состояний и входов;
   - либо загрузите дефолтный пример, либо введите свои таблицы выходов и переходов;
   - нажмите «Запустить минимизацию» и изучите полученный отчёт.

При желании можно сравнить результат с консольной версией `mili_no_int.py`, где распечатываются те же шаги минимизации в текстовом виде.


